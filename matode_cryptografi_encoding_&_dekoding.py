# -*- coding: utf-8 -*-
"""Matode Cryptografi ENCODING & DEKODING.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sr97oBd-KIpvfxoNF88bUod1CZcHEf24

# Metode Caesar

* METODE CAESAR DENGAN ALPHABETH
"""

import string
abjad = string.ascii_letters    # kuncinya
print("Abjad yang digunakan : ",abjad)                    # melihat kunci
# Definisikan Abjad
abjad = string.ascii_letters

# Inputan User
pesan = list(input('Masukkan pesan : '))

# Membuat Pilihan
enkrip_dekrip = input('e = enkripsi / d = deksripsi : ').lower()

kunci = int(input("Masukan Pergesran : "))

# Membuat enkripsi
if enkrip_dekrip == 'e':
    for i in range(len(pesan)):
        if pesan[i] == ' ': 
            pesan[i] = ' '
        elif pesan[i] in string.punctuation:
            jawaban = pesan[i]
        elif pesan[i] in string.digits:
            jawaban = pesan[i]
        elif pesan[i] in string.ascii_uppercase:
            jawaban = (abjad.index(pesan[i]) + kunci) % 26
            pesan[i] = abjad[jawaban].upper()
        else:
            jawaban = (abjad.index(pesan[i]) + kunci) % 26
            pesan[i] = abjad[jawaban]
    print("ENKRIPSI : ",''.join(pesan))

# Membuat dekripsi
elif enkrip_dekrip == 'd':
    for i in range(len(pesan)):
        if pesan[i] == ' ':
            pesan[i] = ' '
        elif pesan[i] in string.punctuation:
            jawaban = pesan[i]
        elif pesan[i] in string.digits:
            jawaban = pesan[i]
        elif pesan[i] in string.ascii_uppercase:
            jawaban = (abjad.index(pesan[i]) - kunci) % 26
            pesan[i] = abjad[jawaban].upper()
        else:
            jawaban = (abjad.index(pesan[i]) - kunci) % 26
            pesan[i] = abjad[jawaban]
    print("DEKRIPSI : ",''.join(pesan))

"""* METODE CAESAR DENGAN ASKY"""

# Import Module
import string       # module untuk mengakses huruf pada python

# Fungsi awal

def operasi(teks, kunci, geser):
    hasil = ''

# Jika Maka Statement

  # Membuat Rumus Enkripsi
    for i in range(len(teks)):              # ini perulangan
        kata = teks[i]                      # ini indeks kata
        if geser == 'e':
            if kata.isupper():              # ispuuper = diubah ke kapital
                hasil += chr((ord(kata) + kunci - 65) % 26 + 65)   # ini rumus caesar   

            elif kata.islower():
                hasil += chr((ord(kata) + kunci - 97) % 26 + 97)

            elif kata in string.punctuation or string.digits:
                hasil += teks[i]
    # Membuat Rumus Dekripsi
        elif geser == 'd':          
            if kata.isupper():
                hasil += chr((ord(kata) - kunci - 65) % 26 + 65)

            elif kata.islower():
                hasil += chr((ord(kata) - kunci - 97) % 26 + 97)

            elif kata in string.punctuation or string.digits:
                hasil += teks[i]

    return hasil


# Membuat Inputan User

while (True):
  perintah = input("Ingin Melakukan Encoding ( y / t) ? :")
  if perintah == 'y':
    teks = input("Masukkan Teks : ")
    kunci = int(input('Masukkan kunci : '))
    geser = input('enkrip or dekrip (e / d) : ').lower()
    print("\nPesan: ", teks)
    print("Kunci: ", kunci)
    print("Hasil: ", operasi(teks, kunci, geser))

  if perintah == 't':
    print("Tetap Jaga Rahasia Teks")
    break

"""# METODE VIGNERE"""

# Kode Python untuk diterapkan
# Vigenere Cipher

# Fungsi ini menghasilkan kunci secara siklik sampai Panjangnya tidak sama dengan panjang teks asli
def generateKey(pesan, key):
	key = list(key)
	if len(string) == len(key):
		return(key)
	else:
		for i in range(len(string) -
					len(key)):
			key.append(key[i % len(key)])
	return("" . join(key))
	
# Fungsi ini mengembalikan teks terenkripsi dihasilkan dengan bantuan kunci
def cipherText(pesan, key):
	cipher_text = []
	for i in range(len(string)):
		x = (ord(string[i]) +
			ord(key[i])) % 26
		x += ord('A')
		cipher_text.append(chr(x))
	return("" . join(cipher_text))
 
# Fungsi ini mendekripsi file Teks terenkripsi dan kembali teks asli
def originalText(cipher_text, key):
	orig_text = []
	for i in range(len(cipher_text)):
		x = (ord(cipher_text[i]) -
			ord(key[i]) + 26) % 26
		x += ord('A')
		orig_text.append(chr(x))
	return("" . join(orig_text))
	
# Driver code
if __name__ == "__main__":
	pesan= "UNDIKSHA"
	keyword = "BALI"
	key = generateKey(pesan, keyword)
	cipher_text = cipherText(pesan,key)
 
 # Menampilkan Enkripsi
	print("Ciphertext :", cipher_text)
 
 # Menampilkan Dekirpsi
	print("Original/Decrypted Text :",
		originalText(cipher_text, key))

"""# METODE RSA"""

# Python untuk algoritma kriptografi asimetris RSA.
# Untuk demonstrasi, nilainya adalah Relatif kecil dibandingkan dengan aplikasi praktis
import math         # Moduule untuk perthitungan Matematika


def gcd(a, h):
	temp = 0
	while(1):
		temp = a % h
		if (temp == 0):
			return h
		a = h
		h = temp


p = 3
q = 7
n = p*q
e = 2
phi = (p-1)*(q-1)

while (e < phi):

# e harus co-prime untuk phi dan
# lebih kecil dari phi.
	if(gcd(e, phi) == 1):
		break
	else:
		e = e+1


# Kunci pribadi (d adalah singkatan dari dekripsi)
# memilih d sedemikian rupa sehingga memuaskan
# d*e = 1 + k * phi/e
k = 2
d = (1 + (k*phi))/e

# Pesan Hanya Berupa Angka
msg = 12.0                  # Ganti Pesan Disini

print("Pesan data = ", msg)

# Enkripsi c = (pesan ^ e)% n
c = pow(msg, e)
c = math.fmod(c, n)
print("Enkripsi data = ", c)

# Dekripsi m = (c ^ d)% n
m = pow(c, d)
m = math.fmod(m, n)
print("Dekripsi Data = ", m)

"""# Metode Play fair"""

# Program Python untuk mengimplementasikan Playfair Cipher

# Berfungsi untuk mengubah string menjadi huruf kecil
def toLowerCase(text):
	return text.lower()
 
# Berfungsi untuk menghapus semua spasi dalam sebuah string
def removeSpaces(text):
	newText = ""
	for i in text:
		if i == " ":
			continue
		else:
			newText = newText + i
	return newText

# Berfungsi untuk mengelompokkan 2 elemen string
# sebagai elemen daftar


def Diagraph(text):
	Diagraph = []
	group = 0
	for i in range(2, len(text), 2):
		Diagraph.append(text[group:i])

		group = i
	Diagraph.append(text[group:])
	return Diagraph


# Berfungsi untuk mengisi huruf pada elemen string
# Jika 2 huruf dalam string yang sama cocok


def FillerLetter(text):
	k = len(text)
	if k % 2 == 0:
		for i in range(0, k, 2):
			if text[i] == text[i+1]:
				new_word = text[0:i+1] + str('x') + text[i+1:]
				new_word = FillerLetter(new_word)
				break
			else:
				new_word = text
	else:
		for i in range(0, k-1, 2):
			if text[i] == text[i+1]:
				new_word = text[0:i+1] + str('x') + text[i+1:]
				new_word = FillerLetter(new_word)
				break
			else:
				new_word = text
	return new_word


list1 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm',
		'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']


# Berfungsi untuk menghasilkan matriks persegi 5x5
def generateKeyTable(word, list1):
	key_letters = []
	for i in word:
		if i not in key_letters:
			key_letters.append(i)

	compElements = []
	for i in key_letters:
		if i not in compElements:
			compElements.append(i)
	for i in list1:
		if i not in compElements:
			compElements.append(i)

	matrix = []
	while compElements != []:
		matrix.append(compElements[:5])
		compElements = compElements[5:]

	return matrix


def search(mat, element):
	for i in range(5):
		for j in range(5):
			if(mat[i][j] == element):
				return i, j


def encrypt_RowRule(matr, e1r, e1c, e2r, e2c):
	char1 = ''
	if e1c == 4:
		char1 = matr[e1r][0]
	else:
		char1 = matr[e1r][e1c+1]

	char2 = ''
	if e2c == 4:
		char2 = matr[e2r][0]
	else:
		char2 = matr[e2r][e2c+1]

	return char1, char2


def encrypt_ColumnRule(matr, e1r, e1c, e2r, e2c):
	char1 = ''
	if e1r == 4:
		char1 = matr[0][e1c]
	else:
		char1 = matr[e1r+1][e1c]

	char2 = ''
	if e2r == 4:
		char2 = matr[0][e2c]
	else:
		char2 = matr[e2r+1][e2c]

	return char1, char2


def encrypt_RectangleRule(matr, e1r, e1c, e2r, e2c):
	char1 = ''
	char1 = matr[e1r][e2c]

	char2 = ''
	char2 = matr[e2r][e1c]

	return char1, char2


def encryptByPlayfairCipher(Matrix, plainList):
	CipherText = []
	for i in range(0, len(plainList)):
		c1 = 0
		c2 = 0
		ele1_x, ele1_y = search(Matrix, plainList[i][0])
		ele2_x, ele2_y = search(Matrix, plainList[i][1])

		if ele1_x == ele2_x:
			c1, c2 = encrypt_RowRule(Matrix, ele1_x, ele1_y, ele2_x, ele2_y)
		elif ele1_y == ele2_y:
			c1, c2 = encrypt_ColumnRule(Matrix, ele1_x, ele1_y, ele2_x, ele2_y)
		else:
			c1, c2 = encrypt_RectangleRule(
				Matrix, ele1_x, ele1_y, ele2_x, ele2_y)

		cipher = c1 + c2
		CipherText.append(cipher)
	return CipherText

# Membuat Inputan Pesan

text_Plain = 'UNDIKSHA'
text_Plain = removeSpaces(toLowerCase(text_Plain))
PlainTextList = Diagraph(FillerLetter(text_Plain))
if len(PlainTextList[-1]) != 2:
	PlainTextList[-1] = PlainTextList[-1]+'z'

key = "SINGARAJA"
print("Key text:", key)
key = toLowerCase(key)
Matrix = generateKeyTable(key, list1)

print("Plain Text:", text_Plain)
CipherList = encryptByPlayfairCipher(Matrix, PlainTextList)

CipherText = ""
for i in CipherList:
	CipherText += i
print("CipherText:", CipherText)

"""# Metode Hill Cipher"""

# Kode Python3 untuk mengimplementasikan Hill Cipher

keyMatrix = [[0] * 3 for i in range(3)]

# Hasilkan vektor untuk pesan
messageVector = [[0] for i in range(3)]

# Hasilkan vektor untuk sandi
cipherMatrix = [[0] for i in range(3)]

# Fungsi berikut menghasilkan
# matriks kunci untuk string kunci
def getKeyMatrix(key):
	k = 0
	for i in range(3):
		for j in range(3):
			keyMatrix[i][j] = ord(key[k]) % 65
			k += 1

# Fungsi berikut mengenkripsi pesan
def encrypt(messageVector):
	for i in range(3):
		for j in range(1):
			cipherMatrix[i][j] = 0
			for x in range(3):
				cipherMatrix[i][j] += (keyMatrix[i][x] *
									messageVector[x][j])
			cipherMatrix[i][j] = cipherMatrix[i][j] % 26

def HillCipher(message, key):

	
# Dapatkan matriks kunci dari string kunci
	getKeyMatrix(key)

	# Hasilkan vektor untuk pesan
	for i in range(3):
		messageVector[i][0] = ord(message[i]) % 65

# Fungsi berikut menghasilkan
# vektor terenkripsi
	encrypt(messageVector)


# Hasilkan teks terenkripsi
# dari vektor terenkripsi
	CipherText = []
	for i in range(3):
		CipherText.append(chr(cipherMatrix[i][0] + 65))
  
# Mengeluarkan Chipertekxt
	print("Hasil Ciphertext : ", "".join(CipherText))

# Membuat Inputan User
def main():

	# Pesan
	message = "DODIK"

	# Kunci
	key = "BGYBNQKURP"

	HillCipher(message, key)

if __name__ == "__main__":
	main()

"""# Metode Affine"""

# Commented out IPython magic to ensure Python compatibility.

# Implementasi Affine Cipher dengan Python

# Extended Euclidean Algorithm untuk menemukan invers modular
# misalnya: modinv(7, 26) = 15
def egcd(a, b):
	x,y, u,v = 0,1, 1,0
	while a != 0:
		q, r = b//a, b%a
		m, n = x-u*q, y-v*q
		b,a, x,y, u,v = a,r, u,v, m,n
	gcd = b
	return gcd, x, y

def modinv(a, m):
	gcd, x, y = egcd(a, m)
	if gcd != 1:
		return None 
# pembalikan modular tidak ada
	else:
		return x % m



# fungsi enkripsi sandi affine
# mengembalikan teks sandi
def affine_encrypt(text, key):
	'''
	C = (a*P + b) % 26
	'''
	return ''.join([ chr((( key[0]*(ord(t) - ord('A')) + key[1] ) % 26)
				+ ord('A')) for t in text.upper().replace(' ', '') ])
 

# fungsi dekripsi affine cipher
# mengembalikan teks asli
def affine_decrypt(cipher, key):
	'''
	P = (a^-1 * (C - b)) % 26
	'''
	return ''.join([ chr((( modinv(key[0], 26)*(ord(c) - ord('A') - key[1]))
# 					% 26) + ord('A')) for c in cipher ])

# Inputan User
def main():


	text = 'UNDIKSHA JAYA'
	key = [17, 20]
  

  # Enkripsi
	affine_encrypted_text = affine_encrypt(text, key)
	print('ENKRIPSI : {}'.format( affine_encrypted_text ))

  # Dekripsi
	print('DEKRIPSI : {}'.format
	( affine_decrypt(affine_encrypted_text, key) ))


if __name__ == '__main__':
	main()